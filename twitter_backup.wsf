<job>
<script language="VBScript">

Sub ruby_install
	strFileURL = "http://files.rubyforge.vm.bytemark.co.uk/rubyinstaller/rubyinstaller-1.9.3-p125.exe"
	strHDLocation = "rubyinstaller-1.9.3-p125.exe"

	Set objXMLHTTP = CreateObject("MSXML2.XMLHTTP")

	objXMLHTTP.open "GET", strFileURL, false
	objXMLHTTP.send()

	If objXMLHTTP.Status = 200 Then
	Set objADOStream = CreateObject("ADODB.Stream")
	objADOStream.Open
	objADOStream.Type = 1 'adTypeBinary

	objADOStream.Write objXMLHTTP.ResponseBody
	objADOStream.Position = 0    'Set the stream position to the start

	Set objFSO = Createobject("Scripting.FileSystemObject")
	If objFSO.Fileexists(strHDLocation) Then objFSO.DeleteFile strHDLocation
	Set objFSO = Nothing

	objADOStream.SaveToFile strHDLocation
	objADOStream.Close
	Set objADOStream = Nothing
	End if

	Set objXMLHTTP = Nothing

	Set wshShell = WScript.CreateObject ("WSCript.shell")
	wshshell.run "rubyinstaller-1.9.3-p125.exe /tasks=assocfiles,modpath", 6, True
	set wshshell = nothing
End Sub



Set wshShell = WScript.CreateObject ("WSCript.shell")
On Error Resume Next
wshshell.run "ruby -version", 6, True
If Err.Number <> 0 Then
    WshShell.Popup(Err.Number)
    ruby_install
    Err.Clear
End If
On Error Goto 0
set wshshell = nothing



Set wshShell = WScript.CreateObject ("WSCript.shell")
Result = InputBox("Twitter user name", "User Name", "yourname", 100, 100)
Result = "C:\Ruby193\bin\ruby -x qwe.wsf " + Result
WshShell.Popup(Result)
wshshell.run Result, 6, True
set wshshell = nothing

WScript.Quit


</script>

<script language="JScript">
/*
#!/usr/bin/env ruby -w
require 'csv'
require 'json'
require "net/http"

USER_TIMELINE_URI = URI.parse("https://api.twitter.com/1/statuses/user_timeline.json")

def usage
  puts 'Usage: twitter_backup.sh screen_name [file_name]'
end

def get_timeline_part(screen_name, count, max_id = nil)
  args = {include_entities: 0, include_rts: 0,
          screen_name: screen_name, count: count, trim_user: 1,
          max_id: max_id}
  USER_TIMELINE_URI.query = URI.encode_www_form(args)
  http = Net::HTTP.new(USER_TIMELINE_URI.host, USER_TIMELINE_URI.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_NONE

  request = Net::HTTP::Get.new(USER_TIMELINE_URI.request_uri)

  attempt = 0
  begin
    attempt+=1
    response = http.request(request)
    JSON response.body
  rescue
    puts "Failed to parse (#{attempt}): " + response.body.scan(/title>(.+)<\/title/)[0]
    if attempt < 3 then
      retry
    else
      raise
    end
  end
end

if ARGV.length == 0
  usage
  exit 1
end

f = File.new 'TwitterBackup.csv', 'a'
csv = CSV.new f, {headers: ['id_str', 'created_at', 'text'], write_headers: true}

counter = 0
last_id_str = nil
while true
  unless last_id_str.nil?
    last_id_str = (last_id_str.to_i - 1).to_s
  end
  timeline_part = get_timeline_part(ARGV[0], 100, last_id_str)
  unless timeline_part.is_a? Array
    p 'Error! ' + timeline_part['error']
    exit 4
  end
  if timeline_part.length == 0
    puts 'Done!'
    exit 0
  end
  timeline_part.each do |x|
    csv << [x['id_str'], x['created_at'], x['text']]
    last_id_str = x['id_str']
    counter += 1
  end
  puts "processed #{counter}, last id was #{last_id_str}..."
end
=begin
*/
</script>
</job>
=end
